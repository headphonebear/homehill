# WHY: Der ClusterIssuer ist die zentrale Konfiguration für Let's Encrypt.
  # Er sagt cert-manager: "Wenn jemand ein Certificate haben will, kontaktiere
  # Let's Encrypt und nutze DNS01 Challenge über den Hetzner Webhook."
  # ClusterIssuer (nicht Issuer) bedeutet: Funktioniert in allen Namespaces.

---
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod
  labels:
    app.kubernetes.io/name: cert-manager-webhook-hetzner
    app.kubernetes.io/component: clusterissuer
spec:
  acme:
    # WHY: Let's Encrypt Production Server. Es gibt auch einen Staging Server
    # (acme-staging-v02.api.letsencrypt.org), der keine Rate Limits hat.
    # Staging nutzen zum Testen, Production für echte Certs!
    server: https://acme-v02.api.letsencrypt.org/directory

    # WHY: Let's Encrypt schickt Ablauf-Warnungen an diese Email.
    # Wichtig: Sollte eine echte, überwachte Email sein!
    email: admin@homehill.de

    # WHY: Let's Encrypt gibt uns einen Account Key, der hier gespeichert wird.
    # Das Secret wird automatisch von cert-manager erstellt - wir müssen es
    # nicht manuell anlegen. Der Key ist wichtig für Certificate Renewals!
    privateKeySecretRef:
      name: letsencrypt-key-prod

    solvers:
      # WHY: DNS01 Challenge ist perfekt für Wildcard Certs und wenn Port 80
      # nicht erreichbar ist. Let's Encrypt prüft: "Kannst du einen TXT Record
      # in _acme-challenge.homehill.de setzen?" Wenn ja: Du besitzt die Domain!
      - dns01:
          webhook:
            # WHY: solverName verbindet diesen Solver mit dem Webhook Pod.
            # Der Webhook registriert sich unter diesem Namen bei cert-manager.
            solverName: hetzner

            # WHY: groupName MUSS identisch mit values.yaml sein!
            # Das ist der "Schlüssel" der Webhook und ClusterIssuer verbindet.
            # Früher: acme.hetzner.com (falsch!), jetzt: acme.homehill.de
            groupName: acme.homehill.de

            config:
              # WHY: Hier steht, wo der Webhook den Hetzner API Token findet.
              # Secret Name: "hetzner" (haben wir oben gefixt!)
              # Secret Key: "token" (nicht "api-key"!)
              # Das muss exakt mit dem SealedSecret übereinstimmen.
              tokenSecretKeyRef:
                name: hetzner
                key: token
